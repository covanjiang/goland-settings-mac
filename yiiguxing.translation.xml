<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="613" />
    <option name="newTranslationDialogWidth" value="1050" />
    <option name="newTranslationDialogX" value="267" />
    <option name="newTranslationDialogY" value="218" />
    <histories>
      <item value="Select" />
      <item value="The error built-in interface type is the conventional interface for&#10; representing an error condition, with the nil value representing no error." />
      <item value="Indicator" />
      <item value="We don't want the entry's metadata to be quoted and escaped (if it's&#10;&#9; encoded as strings), which means that we can't use the JSON encoder. The&#10;&#9; simplest option is to use the memory encoder and fmt.Fprint.&#10;&#9;&#10;&#9; If this ever becomes a performance bottleneck, we can implement&#10;&#9; ArrayEncoder for our plain-text format." />
      <item value="Configure the primitive representations of common complex types. For&#10;&#9; example, some users may want all time.Times serialized as floating-point&#10;&#9; seconds since epoch, while others may prefer ISO8601 strings." />
      <item value="defines the key to use when callers want to remove a key from log output." />
      <item value="relative path" />
      <item value="et rotate daily (chainable). Must be called before the first log message is" />
      <item value="Set file log saving hours, if file is expired, will be deleted now." />
      <item value="Word Date" />
      <item value="Indent appends to dst an indented form of the JSON-encoded src. Each element in a JSON object or array begins on a new, indented line beginning with prefix followed by one or more copies of indent according to the indentation nesting. The data appended to dst does not begin with the prefix nor any indentation, to make it easier to embed inside other formatted JSON data. Although leading space characters (space, tab, carriage return, newline) at the beginning of src are dropped, trailing space characters at the end of src are preserved and copied to dst. For example, if src has no trailing spaces, neither will dst; if src ends in a trailing newline, so will dst." />
      <item value="external action" />
      <item value="defines the functions clients need to perform unary and&#10; streaming RPCs.  It is implemented by ClientConn, and is only intended to&#10; be referenced by generated code." />
      <item value="ddFunc adds a func to the Cron to be run on the given schedule.&#10; The spec is parsed using the time zone of this Cron instance as the default.&#10; An opaque ID is returned that can be used to later remove it." />
      <item value="Campaign" />
      <item value="must start a consumer loop of ConsumerGroupClaim's Messages()." />
      <item value="For each of the assigned claims the handler's ConsumeClaim() function is then called&#10;&#9;    in a separate goroutine which requires it to be thread-safe. Any state must be carefully protected" />
      <item value="Please note, that once a rebalance is triggered, sessions must be completed within&#10;&#9; Config.Consumer.Group.Rebalance.Timeout. This means that ConsumeClaim() functions must exit&#10;&#9; as quickly as possible to allow time for Cleanup() and the final offset commit. If the timeout&#10;&#9; is exceeded, the consumer will be removed from the group by Kafka, which will cause offset&#10;&#9; commit failures." />
      <item value="Once all the ConsumeClaim() loops have exited, the handler's Cleanup() hook is called&#10;&#9;    to allow the user to perform any final tasks before a rebalance." />
      <item value="The session will persist until one of the ConsumeClaim() functions exits. This can be either when the&#10;&#9;    parent context is cancelled or when a server-side rebalance cycle is initiated." />
      <item value="For each of the assigned claims the handler's ConsumeClaim() function is then called&#10;&#9;    in a separate goroutine which requires it to be thread-safe. Any state must be carefully protected&#10;&#9;    from concurrent readswrites." />
      <item value="must start a consumer loop of ConsumerGroupClaim's Messages().&#10;&#9; Once the Messages() channel is closed, the Handler must finish its processing&#10;&#9; loop and exit." />
      <item value=" Consume joins a cluster of consumers for a given list of topics and&#10;&#9; starts a blocking ConsumerGroupSession through the ConsumerGroupHandler.&#10;&#9;&#10;&#9; The life-cycle of a session is represented by the following steps:&#10;&#9;&#10;&#9; 1. The consumers join the group (as explained in https:kafka.apache.orgdocumentationintro_consumers)&#10;&#9;    and is assigned their &quot;fair share&quot; of partitions, aka 'claims'.&#10;&#9; 2. Before processing starts, the handler's Setup() hook is called to notify the user&#10;&#9;    of the claims and allow any necessary preparation or alteration of state.&#10;&#9; 3. For each of the assigned claims the handler's ConsumeClaim() function is then called&#10;&#9;    in a separate goroutine which requires it to be thread-safe. Any state must be carefully protected&#10;&#9;    from concurrent readswrites.&#10;&#9; 4. The session will persist until one of the ConsumeClaim() functions exits. This can be either when the&#10;&#9;    parent context is cancelled or when a server-side rebalance cycle is initiated.&#10;&#9; 5. Once all the ConsumeClaim() loops have exited, the handler's Cleanup() hook is called&#10;&#9;    to allow the user to perform any final tasks before a rebalance.&#10;&#9; 6. Finally, marked offsets are committed one last time before claims are released.&#10;&#9;&#10;&#9; Please note, that once a rebalance is triggered, sessions must be completed within&#10;&#9; Config.Consumer.Group.Rebalance.Timeout. This means that ConsumeClaim() functions must exit&#10;&#9; as quickly as possible to allow time for Cleanup() and the final offset commit. If the timeout&#10;&#9; is exceeded, the consumer will be removed from the group by Kafka, which will cause offset&#10;&#9; commit failures.&#10;&#9; This method should be called inside an infinite loop, when a&#10;&#9; server-side rebalance happens, the consumer session will need to be&#10;&#9; recreated to get the new claims." />
      <item value="`Consume` should be called inside an infinite loop, when a&#10;&#9;&#9;&#9; server-side rebalance happens, the consumer session will need to be&#10;&#9;&#9;&#9; recreated to get the new claims" />
      <item value="Background returns a non-nil, empty Context. It is never canceled, has no&#10; values, and has no deadline. It is typically used by the main function,&#10; initialization, and tests, and as the top-level Context for incoming&#10; requests." />
      <item value="WithCancel returns a copy of parent with a new Done channel. The returned&#10; context's Done channel is closed when the returned cancel function is called&#10; or when the parent context's Done channel is closed, whichever happens first.&#10;&#10; Canceling this context releases resources associated with it, so code should&#10; call cancel as soon as the operations running in this Context complete." />
      <item value="returns a copy of parent with a new Done channel. The returned&#10; context's Done channel is closed when the returned cancel function is called&#10; or when the parent context's Done channel is closed, whichever happens first.&#10;&#10; Canceling this context releases resources associated with it, so code should&#10; call cancel as soon as the operations running in this Context complete." />
      <item value="Getwd returns a rooted path name corresponding to the&#10; current directory. If the current directory can be&#10; reached via multiple paths (due to symbolic links),&#10; Getwd may return any one of them." />
      <item value="Getwd returns a rooted path name corresponding to the current directory. If the current directory can be reached via multiple paths (due to symbolic links), Getwd may return any one of them." />
      <item value="returns the reverse order for data." />
      <item value="Pop removes and returns the minimum element (according to Less) from the heap.&#10; The complexity is O(log n) where n = h.Len().&#10; Pop is equivalent to Remove(h, 0)." />
      <item value="SearchInts searches for x in a sorted slice of ints and returns the index&#10; as specified by Search. The return value is the index to insert x if x is&#10; not present (it could be len(a)).&#10; The slice must be sorted in ascending order." />
      <item value="Fix re-establishes the heap ordering after the element at index i has changed its value.&#10; Changing the value of the element at index i and then calling Fix is equivalent to,&#10; but less expensive than, calling Remove(h, i) followed by a Push of the new value.&#10; The complexity is O(log n) where n = h.Len()." />
      <item value="IntSlice attaches the methods of Interface to []int, sorting in increasing order." />
      <item value="Scan scans text read from standard input, storing successive&#10; space-separated values into successive arguments. Newlines count&#10; as space. It returns the number of items successfully scanned.&#10; If that is less than the number of arguments, err will report why." />
      <item value="is a variable-sized buffer of bytes with Read and Write methods.&#10; The zero value for Buffer is an empty buffer ready to use." />
      <item value="Marshal traverses the value v recursively.&#10; If an encountered value implements the Marshaler interface&#10; and is not a nil pointer, Marshal calls its MarshalJSON method&#10; to produce JSON. If no MarshalJSON method is present but the&#10; value implements encoding.TextMarshaler instead, Marshal calls&#10; its MarshalText method and encodes the result as a JSON string.&#10; The nil pointer exception is not strictly necessary&#10; but mimics a similar, necessary exception in the behavior of&#10; UnmarshalJSON." />
      <item value=" Marshal returns the JSON encoding of v.&#10;" />
      <item value="adds the elements of the argument map to the template's function map.&#10; It panics if a value in the map is not a function with appropriate return&#10; type. However, it is legal to overwrite elements of the map. The return&#10; value is the template, so calls can be chained." />
      <item value="FuncMap is the type of the map defining the mapping from names to functions.&#10; Each function must have either a single return value, or two return values of&#10; which the second has type error. In that case, if the second (error)&#10; return value evaluates to non-nil during execution, execution terminates and&#10; Execute returns that error." />
      <item value="checks the Content-Type to select a binding engine automatically,&#10; Depending the &quot;Content-Type&quot; header different bindings are used:&#10;     &quot;applicationjson&quot; --&gt; JSON binding&#10;     &quot;applicationxml&quot;  --&gt; XML binding&#10; otherwise --&gt; returns an error&#10; It parses the request's body as JSON if Content-Type == &quot;applicationjson&quot; using JSON or XML as a JSON input.&#10; It decodes the json payload into the struct specified as a pointer.&#10; Like c.Bind() but this method does not set the response status code to 400 and abort if the json is not valid." />
      <item value=" set log mode, `true` for detailed logs, `false` for no log, default, will only print error logs" />
      <item value="use singular table by default" />
      <item value="takes a single key and unmarshals it into a Struct." />
      <item value="Viper is a prioritized configuration registry. It&#10; maintains a set of configuration sources, fetches&#10; values to populate those, and provides them according&#10; to the source's priority." />
      <item value="itle returns a copy of the string s with all Unicode letters that begin words&#10; mapped to their Unicode title case." />
      <item value="Replace returns a copy of the string s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string. If n &lt; 0, there is no limit on the number of replacements.&#10;" />
      <item value="Parse parses flag definitions from the argument list, which should not&#10; include the command name. Must be called after all flags in the FlagSet&#10; are defined and before flags are accessed by the program.&#10; The return value will be ErrHelp if -help or -h were set but not defined." />
      <item value="NewFlagSet returns a new, empty flag set with the specified name and&#10; error handling property. If the name is not empty, it will be printed&#10; in the default usage message and in error messages." />
      <item value="These routines do not take a format string" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="39" />
        <entry key="ENGLISH" value="40" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1660885910455" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1728529513183" />
  </component>
  <component name="Translation.Settings">
    <option name="primaryLanguage" value="CHINESE" />
    <option name="ttsEngine" value="GOOGLE" />
  </component>
  <component name="Translation.States">
    <histories>
      <item value="Errors is the error output channel back to the user. You MUST read from this channel or the Producer will deadlock when the channel is full. Alternatively, you can set Producer.Return.Errors in your config to false, which prevents errors to be returned." />
      <item value="Successes is the success output channel back to the user when Return.Successes is enabled. If Return.Successes is true, you MUST read from this channel or the Producer will deadlock. It is suggested that you send and read messages together in a single select statement." />
      <item value="highWatermark tracks the &quot;current&quot; retry level, which is the only one where we actually let messages through, all other messages get buffered in retryState[msg.retries].buf to preserve ordering retryState[msg.retries].expectChaser simply tracks whether we've seen a fin message for a given level (and therefore whether our buffer is complete and safe to flush)" />
      <item value="Called to compute backoff time dynamically. Useful for implementing more sophisticated backoff strategies. This takes precedence over `Backoff` if set." />
      <item value="The best-effort frequency of flushes. Equivalent to `queue.buffering.max.ms` setting of JVM producer." />
      <item value="The best-effort number of bytes needed to trigger a flush. Use the global sarama.MaxRequestSize to set a hard upper limit." />
      <item value="The following config options control how often messages are batched up and sent to the broker. By default, messages are sent as fast as possible, and all messages received while the current batch is in-flight are placed into the subsequent batch." />
      <item value="How many outstanding requests a connection is allowed to have before sending on it blocks (default 5). Throughput can improve but message ordering is not guaranteed if Producer.Idempotent is disabled, see: https:kafka.apache.orgprotocolprotocol_network https:kafka.apache.org28documentation.htmlproducerconfigs_max.in.flight.requests.per.connection" />
      <item value="If enabled, the producer will ensure that exactly one copy of each message is written." />
      <item value="The level of compression to use on messages. The meaning depends on the actual compression type used and defaults to default compression level for the codec." />
      <item value="The type of compression to use on messages (defaults to no compression). Similar to `compression.codec` setting of the JVM producer." />
      <item value="CompressionLevelDefault is the constant to use in CompressionLevel to have the default compression level for any codec. The value is picked that we don't use any existing compression levels." />
      <item value="Bit 3 set for &quot;LogAppend&quot; timestamps" />
      <item value="The lowest 3 bits contain the compression codec used for the message" />
      <item value="If enabled, successfully delivered messages will be returned on the Successes channel (default disabled)." />
      <item value="Generates partitioners for choosing the partition to send messages to (defaults to hashing the message key). Similar to the `partitioner.class` setting for the JVM producer." />
      <item value="RequiresConsistency indicates to the user of the partitioner whether the mapping of key-&gt;partition is consistent or not. Specifically, if a partitioner requires consistency then it must be allowed to choose from all partitions (even ones known to be unavailable), and its choice must be respected by the caller. The obvious example is the HashPartitioner." />
      <item value="How long to wait for the cluster to settle between retries (default 100ms). Similar to the `retry.backoff.ms` setting of the JVM producer." />
      <item value="Retry struct { The total number of times to retry sending a message (default 3). Similar to the `message.send.max.retries` setting of the JVM producer. Max int How long to wait for the cluster to settle between retries (default 100ms). Similar to the `retry.backoff.ms` setting of the JVM producer. Backoff time.Duration Called to compute backoff time dynamically. Useful for implementing more sophisticated backoff strategies. This takes precedence over `Backoff` if set. BackoffFunc func(retries, maxRetries int) time.Duration }" />
      <item value="RequiredAcks is used in Produce Requests to tell the broker how many replica acknowledgements it must see before responding. Any of the constants defined here are valid. On broker versions prior to 0.8.2.0 any other positive int16 is also valid (the broker will wait for that many acknowledgements) but in 0.8.2.0 and later this will raise an exception (it has been replaced by setting the `min.isr` value in the brokers configuration)." />
      <item value="WaitForAll waits for all in-sync replicas to commit before responding. The minimum number of in-sync replicas is configured on the broker via the `min.insync.replicas` configuration key." />
      <item value="WaitForLocal waits for only the local commit to succeed before responding." />
      <item value="NoResponse doesn't send any response, the TCP ACK is all you get." />
      <item value="const ( NoResponse doesn't send any response, the TCP ACK is all you get. NoResponse RequiredAcks = 0 WaitForLocal waits for only the local commit to succeed before responding. WaitForLocal RequiredAcks = 1 WaitForAll waits for all in-sync replicas to commit before responding. The minimum number of in-sync replicas is configured on the broker via the `min.insync.replicas` configuration key. WaitForAll RequiredAcks = -1 )" />
      <item value="Close closes the client, releasing any open resources. It is rare to Close a Client, as the Client is meant to be long-lived and shared between many goroutines." />
      <item value="ObserveDuration records the duration passed since the Timer was created with NewTimer. It calls the Observe method of the Observer provided during construction with the duration in seconds as an argument. The observed duration is also returned. ObserveDuration is usually called with a defer statement. Note that this method is only guaranteed to never observe negative durations if used with Go1.9+." />
      <item value="NewTimer creates a new Timer. The provided Observer is used to observe a duration in seconds. Timer is usually used to time a function call in the following way: func TimeMe() { timer := NewTimer(myHistogram) defer timer.ObserveDuration() Do actual work. }" />
      <item value="Timer is a helper type to time functions. Use NewTimer to create new instances." />
      <item value="UniversalClient is an abstract client which - based on the provided options - represents either a ClusterClient, a FailoverClient, or a single-node Client. This can be useful for testing cluster-specific applications locally or having different clients in different environments." />
      <item value="Timeout for socket writes. If reached, commands will fail with a timeout instead of blocking. Supported values: - `0` - default timeout (3 seconds). - `-1` - no timeout (block indefinitely). - `-2` - disables SetWriteDeadline calls completely." />
      <item value="Timeout for socket reads. If reached, commands will fail with a timeout instead of blocking. Supported values: - `0` - default timeout (3 seconds). - `-1` - no timeout (block indefinitely). - `-2` - disables SetReadDeadline calls completely." />
      <item value="Mask is an optional rune that sets which character to display instead of the entered characters. This allows hiding private information like passwords." />
      <item value="AllowEdit lets the user edit the default value. If false, any key press other than &lt;Enter&gt; automatically clears the default value." />
      <item value="ParseStandard returns a new crontab schedule representing the given standardSpec (https:en.wikipedia.orgwikiCron). It requires 5 entries representing: minute, hour, day of month, month and day of week, in that order. It returns a descriptive error if the spec is not valid. It accepts - Standard crontab specs, e.g. &quot; ?&quot; - Descriptors, e.g. &quot;@midnight&quot;, &quot;@every 1h30m&quot;" />
      <item value="Getwd returns a rooted path name corresponding to the current directory. If the current directory can be reached via multiple paths (due to symbolic links), Getwd may return any one of them." />
      <item value="MaxBackups is the maximum number of old log files to retain. The default is to retain all old log files (though MaxAge may still cause them to get deleted.)" />
      <item value="payload holds data needed to perform the task." />
      <item value="sema is a counting semaphore to ensure the number of active workers does not exceed the limit." />
      <item value="An aggregator is responsible for checking groups and aggregate into one task if any of the grouping condition is met." />
      <item value="healthchecker is responsible for pinging broker periodically and call user provided HeathCheckFunc with the ping result." />
      <item value="A janitor is responsible for deleting expired completed tasks from the specified queues. It periodically checks for any expired tasks in the completed set, and deletes them." />
      <item value="Sleep to avoid slamming redis and let scheduler move tasks into queues. Note: We are not using blocking pop operation and polling queues instead. This adds significant load to redis." />
      <item value="Dequeue queries given queues in order and pops a task message off a queue if one exists and returns the message and its lease expiration time. Dequeue skips a queue if the queue is paused. If all queues are empty, ErrNoProcessableTask error is returned." />
      <item value="queues returns a list of queues to query. Order of the queue names is based on the priority of each queue. Queue names is sorted by their priority level if strict-priority is true. If strict-priority is false, then the order of queue names are roughly based on the priority level but randomized in order to avoid starving low priority queues." />
      <item value="A forwarder is responsible for moving scheduled and retry tasks to pending state so that the tasks get processed by the workers." />
      <item value="heartbeater is responsible for writing process info to redis periodically to indicate that the background worker process is up." />
      <item value="Try sync one last time before shutting down." />
      <item value="syncer is responsible for queuing up failed requests to redis and retry those requests to sync state between the background process and redis." />
      <item value="TODO: Create a helper to check for zero value and fall back to default (e.g. getDurationOrDefault())" />
      <item value="reate a helper to check for zero value and fall back to default (e.g. getDurationOrDefault())" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="97" />
        <entry key="CHINESE_SIMPLIFIED" value="39" />
        <entry key="ENGLISH" value="137" />
      </map>
    </option>
  </component>
</application>