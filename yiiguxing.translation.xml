<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="613" />
    <option name="newTranslationDialogWidth" value="1050" />
    <option name="newTranslationDialogX" value="267" />
    <option name="newTranslationDialogY" value="218" />
    <histories>
      <item value="Select" />
      <item value="The error built-in interface type is the conventional interface for&#10; representing an error condition, with the nil value representing no error." />
      <item value="Indicator" />
      <item value="We don't want the entry's metadata to be quoted and escaped (if it's&#10;&#9; encoded as strings), which means that we can't use the JSON encoder. The&#10;&#9; simplest option is to use the memory encoder and fmt.Fprint.&#10;&#9;&#10;&#9; If this ever becomes a performance bottleneck, we can implement&#10;&#9; ArrayEncoder for our plain-text format." />
      <item value="Configure the primitive representations of common complex types. For&#10;&#9; example, some users may want all time.Times serialized as floating-point&#10;&#9; seconds since epoch, while others may prefer ISO8601 strings." />
      <item value="defines the key to use when callers want to remove a key from log output." />
      <item value="relative path" />
      <item value="et rotate daily (chainable). Must be called before the first log message is" />
      <item value="Set file log saving hours, if file is expired, will be deleted now." />
      <item value="Word Date" />
      <item value="Indent appends to dst an indented form of the JSON-encoded src. Each element in a JSON object or array begins on a new, indented line beginning with prefix followed by one or more copies of indent according to the indentation nesting. The data appended to dst does not begin with the prefix nor any indentation, to make it easier to embed inside other formatted JSON data. Although leading space characters (space, tab, carriage return, newline) at the beginning of src are dropped, trailing space characters at the end of src are preserved and copied to dst. For example, if src has no trailing spaces, neither will dst; if src ends in a trailing newline, so will dst." />
      <item value="external action" />
      <item value="defines the functions clients need to perform unary and&#10; streaming RPCs.  It is implemented by ClientConn, and is only intended to&#10; be referenced by generated code." />
      <item value="ddFunc adds a func to the Cron to be run on the given schedule.&#10; The spec is parsed using the time zone of this Cron instance as the default.&#10; An opaque ID is returned that can be used to later remove it." />
      <item value="Campaign" />
      <item value="must start a consumer loop of ConsumerGroupClaim's Messages()." />
      <item value="For each of the assigned claims the handler's ConsumeClaim() function is then called&#10;&#9;    in a separate goroutine which requires it to be thread-safe. Any state must be carefully protected" />
      <item value="Please note, that once a rebalance is triggered, sessions must be completed within&#10;&#9; Config.Consumer.Group.Rebalance.Timeout. This means that ConsumeClaim() functions must exit&#10;&#9; as quickly as possible to allow time for Cleanup() and the final offset commit. If the timeout&#10;&#9; is exceeded, the consumer will be removed from the group by Kafka, which will cause offset&#10;&#9; commit failures." />
      <item value="Once all the ConsumeClaim() loops have exited, the handler's Cleanup() hook is called&#10;&#9;    to allow the user to perform any final tasks before a rebalance." />
      <item value="The session will persist until one of the ConsumeClaim() functions exits. This can be either when the&#10;&#9;    parent context is cancelled or when a server-side rebalance cycle is initiated." />
      <item value="For each of the assigned claims the handler's ConsumeClaim() function is then called&#10;&#9;    in a separate goroutine which requires it to be thread-safe. Any state must be carefully protected&#10;&#9;    from concurrent readswrites." />
      <item value="must start a consumer loop of ConsumerGroupClaim's Messages().&#10;&#9; Once the Messages() channel is closed, the Handler must finish its processing&#10;&#9; loop and exit." />
      <item value=" Consume joins a cluster of consumers for a given list of topics and&#10;&#9; starts a blocking ConsumerGroupSession through the ConsumerGroupHandler.&#10;&#9;&#10;&#9; The life-cycle of a session is represented by the following steps:&#10;&#9;&#10;&#9; 1. The consumers join the group (as explained in https:kafka.apache.orgdocumentationintro_consumers)&#10;&#9;    and is assigned their &quot;fair share&quot; of partitions, aka 'claims'.&#10;&#9; 2. Before processing starts, the handler's Setup() hook is called to notify the user&#10;&#9;    of the claims and allow any necessary preparation or alteration of state.&#10;&#9; 3. For each of the assigned claims the handler's ConsumeClaim() function is then called&#10;&#9;    in a separate goroutine which requires it to be thread-safe. Any state must be carefully protected&#10;&#9;    from concurrent readswrites.&#10;&#9; 4. The session will persist until one of the ConsumeClaim() functions exits. This can be either when the&#10;&#9;    parent context is cancelled or when a server-side rebalance cycle is initiated.&#10;&#9; 5. Once all the ConsumeClaim() loops have exited, the handler's Cleanup() hook is called&#10;&#9;    to allow the user to perform any final tasks before a rebalance.&#10;&#9; 6. Finally, marked offsets are committed one last time before claims are released.&#10;&#9;&#10;&#9; Please note, that once a rebalance is triggered, sessions must be completed within&#10;&#9; Config.Consumer.Group.Rebalance.Timeout. This means that ConsumeClaim() functions must exit&#10;&#9; as quickly as possible to allow time for Cleanup() and the final offset commit. If the timeout&#10;&#9; is exceeded, the consumer will be removed from the group by Kafka, which will cause offset&#10;&#9; commit failures.&#10;&#9; This method should be called inside an infinite loop, when a&#10;&#9; server-side rebalance happens, the consumer session will need to be&#10;&#9; recreated to get the new claims." />
      <item value="`Consume` should be called inside an infinite loop, when a&#10;&#9;&#9;&#9; server-side rebalance happens, the consumer session will need to be&#10;&#9;&#9;&#9; recreated to get the new claims" />
      <item value="Background returns a non-nil, empty Context. It is never canceled, has no&#10; values, and has no deadline. It is typically used by the main function,&#10; initialization, and tests, and as the top-level Context for incoming&#10; requests." />
      <item value="WithCancel returns a copy of parent with a new Done channel. The returned&#10; context's Done channel is closed when the returned cancel function is called&#10; or when the parent context's Done channel is closed, whichever happens first.&#10;&#10; Canceling this context releases resources associated with it, so code should&#10; call cancel as soon as the operations running in this Context complete." />
      <item value="returns a copy of parent with a new Done channel. The returned&#10; context's Done channel is closed when the returned cancel function is called&#10; or when the parent context's Done channel is closed, whichever happens first.&#10;&#10; Canceling this context releases resources associated with it, so code should&#10; call cancel as soon as the operations running in this Context complete." />
      <item value="Getwd returns a rooted path name corresponding to the&#10; current directory. If the current directory can be&#10; reached via multiple paths (due to symbolic links),&#10; Getwd may return any one of them." />
      <item value="Getwd returns a rooted path name corresponding to the current directory. If the current directory can be reached via multiple paths (due to symbolic links), Getwd may return any one of them." />
      <item value="returns the reverse order for data." />
      <item value="Pop removes and returns the minimum element (according to Less) from the heap.&#10; The complexity is O(log n) where n = h.Len().&#10; Pop is equivalent to Remove(h, 0)." />
      <item value="SearchInts searches for x in a sorted slice of ints and returns the index&#10; as specified by Search. The return value is the index to insert x if x is&#10; not present (it could be len(a)).&#10; The slice must be sorted in ascending order." />
      <item value="Fix re-establishes the heap ordering after the element at index i has changed its value.&#10; Changing the value of the element at index i and then calling Fix is equivalent to,&#10; but less expensive than, calling Remove(h, i) followed by a Push of the new value.&#10; The complexity is O(log n) where n = h.Len()." />
      <item value="IntSlice attaches the methods of Interface to []int, sorting in increasing order." />
      <item value="Scan scans text read from standard input, storing successive&#10; space-separated values into successive arguments. Newlines count&#10; as space. It returns the number of items successfully scanned.&#10; If that is less than the number of arguments, err will report why." />
      <item value="is a variable-sized buffer of bytes with Read and Write methods.&#10; The zero value for Buffer is an empty buffer ready to use." />
      <item value="Marshal traverses the value v recursively.&#10; If an encountered value implements the Marshaler interface&#10; and is not a nil pointer, Marshal calls its MarshalJSON method&#10; to produce JSON. If no MarshalJSON method is present but the&#10; value implements encoding.TextMarshaler instead, Marshal calls&#10; its MarshalText method and encodes the result as a JSON string.&#10; The nil pointer exception is not strictly necessary&#10; but mimics a similar, necessary exception in the behavior of&#10; UnmarshalJSON." />
      <item value=" Marshal returns the JSON encoding of v.&#10;" />
      <item value="adds the elements of the argument map to the template's function map.&#10; It panics if a value in the map is not a function with appropriate return&#10; type. However, it is legal to overwrite elements of the map. The return&#10; value is the template, so calls can be chained." />
      <item value="FuncMap is the type of the map defining the mapping from names to functions.&#10; Each function must have either a single return value, or two return values of&#10; which the second has type error. In that case, if the second (error)&#10; return value evaluates to non-nil during execution, execution terminates and&#10; Execute returns that error." />
      <item value="checks the Content-Type to select a binding engine automatically,&#10; Depending the &quot;Content-Type&quot; header different bindings are used:&#10;     &quot;applicationjson&quot; --&gt; JSON binding&#10;     &quot;applicationxml&quot;  --&gt; XML binding&#10; otherwise --&gt; returns an error&#10; It parses the request's body as JSON if Content-Type == &quot;applicationjson&quot; using JSON or XML as a JSON input.&#10; It decodes the json payload into the struct specified as a pointer.&#10; Like c.Bind() but this method does not set the response status code to 400 and abort if the json is not valid." />
      <item value=" set log mode, `true` for detailed logs, `false` for no log, default, will only print error logs" />
      <item value="use singular table by default" />
      <item value="takes a single key and unmarshals it into a Struct." />
      <item value="Viper is a prioritized configuration registry. It&#10; maintains a set of configuration sources, fetches&#10; values to populate those, and provides them according&#10; to the source's priority." />
      <item value="itle returns a copy of the string s with all Unicode letters that begin words&#10; mapped to their Unicode title case." />
      <item value="Replace returns a copy of the string s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string. If n &lt; 0, there is no limit on the number of replacements.&#10;" />
      <item value="Parse parses flag definitions from the argument list, which should not&#10; include the command name. Must be called after all flags in the FlagSet&#10; are defined and before flags are accessed by the program.&#10; The return value will be ErrHelp if -help or -h were set but not defined." />
      <item value="NewFlagSet returns a new, empty flag set with the specified name and&#10; error handling property. If the name is not empty, it will be printed&#10; in the default usage message and in error messages." />
      <item value="These routines do not take a format string" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="39" />
        <entry key="ENGLISH" value="40" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1660885910455" />
  </component>
  <component name="Settings">
    <option name="keepFormat" value="true" />
  </component>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1680686213414" />
  </component>
  <component name="Translation.Settings">
    <option name="translator" value="MICROSOFT" />
  </component>
  <component name="Translation.States">
    <histories>
      <item value="Pending" />
      <item value="Body is the request's body. For client requests, a nil body means the request has no body, such as a GET request. The HTTP Client's Transport is responsible for calling the Close method. For server requests, the Request Body is always non-nil but will return EOF immediately when no body is present. The Server will close the request body. The ServeHTTP Handler does not need to. Body must allow Read to be called concurrently with Close. In particular, calling Close should unblock a Read waiting for input." />
      <item value="Double and clamp for next time." />
      <item value="Add 10% jitter." />
      <item value="Once Shutdown has been called on a server, it may not be reused; future calls to methods such as Serve will return ErrServerClosed." />
      <item value="Shutdown does not attempt to close nor wait for hijacked connections such as WebSockets. The caller of Shutdown should separately notify such long-lived connections of shutdown and wait for them to close, if desired. See RegisterOnShutdown for a way to register shutdown notification functions." />
      <item value="When Shutdown is called, Serve, ListenAndServe, and ListenAndServeTLS immediately return ErrServerClosed. Make sure the program doesn't exit and waits instead for Shutdown to return." />
      <item value="Shutdown gracefully shuts down the server without interrupting any active connections. Shutdown works by first closing all open listeners, then closing all idle connections, and then waiting indefinitely for connections to return to idle and then shut down. If the provided context expires before the shutdown is complete, Shutdown returns the context's error, otherwise it returns any error returned from closing the Server's underlying Listener(s)." />
      <item value="The upper layer of the root directory is still the root directory. So &quot;..&quot; And &quot;.&quot; will be cleared for example 1. &quot;..&quot; or &quot;.&quot; =&gt; &quot;&quot; 2. &quot;.....&quot; or &quot;....&quot; =&gt; &quot;...&quot; 3. &quot;...x.&quot; or &quot;..x.&quot; =&gt; &quot;.x.&quot; 4. &quot;x\\y&quot; = &gt; &quot;zx&quot;" />
      <item value="RemoveAll removes path and any children it contains. It removes everything it can but returns the first error it encounters. If the path does not exist, RemoveAll returns nil (no error). If there is an error, it will be of type PathError." />
      <item value="tries to be 100% compatible with standard library behavior" />
      <item value="create nested file" />
      <item value="IsNotExist returns a boolean indicating whether the error is known to report that a file or directory does not exist. It is satisfied by ErrNotExist as well as some syscall errors. This function predates errors.Is. It only supports errors returned by the os package. New code should use errors.Is(err, fs.ErrNotExist)." />
      <item value="Executable returns the path name for the executable that started the current process. There is no guarantee that the path is still pointing to the correct executable. If a symlink was used to start the process, depending on the operating system, the result might be the symlink or the path it pointed to. If a stable result is needed, pathfilepath.EvalSymlinks might help. Executable returns an absolute path unless an error occurred. The main use case is finding resources located relative to an executable." />
      <item value="Force to use the directory where the binary file is located as data directory" />
      <item value="Cobra supports local flags which will only run when this command is called directly, e.g.: serverCmd.Flags().BoolP(&quot;toggle&quot;, &quot;t&quot;, false, &quot;Help message for toggle&quot;)" />
      <item value="Cobra supports Persistent Flags which will work for this command and all subcommands, e.g.: serverCmd.PersistentFlags().String(&quot;foo&quot;, &quot;&quot;, &quot;A help for foo&quot;)" />
      <item value="here you will define your flags and configuration settings." />
      <item value="Contributor Covenant Code of Conduct" />
      <item value="Struct Credit has methods on both value and pointer receivers. Such usage is not recommended by the Go Documentation." />
      <item value="scene" />
      <item value="Report Recent Consumption" />
      <item value="Logfile" />
      <item value="Send first packet of payload together with request, in favor of small requests." />
      <item value="Send first packet of payload together with request, in favor of small requests" />
      <item value="Commands lists the available commands and help topics. The order here is the order in which they are printed by 'go help'. Note that subcommands are in general best avoided." />
      <item value="The following are neccesary as they register handlers in their init functions." />
      <item value="The server is not started at this point." />
      <item value="Reader is the interface that wraps the basic Read method. Read reads up to len(p) bytes into p. It returns the number of bytes read (0 &lt;= n &lt;= len(p)) and any error encountered. Even if Read returns n &lt; len(p), it may use all of p as scratch space during the call. If some data is available but not len(p) bytes, Read conventionally returns what is available instead of waiting for more. When Read encounters an error or end-of-file condition after successfully reading n &gt; 0 bytes, it returns the number of bytes read. It may return the (non-nil) error from the same call or return the error (and n == 0) from a subsequent call. An instance of this general case is that a Reader returning a non-zero number of bytes at the end of the input stream may return either err == EOF or err == nil. The next Read should return 0, EOF. Callers should always process the n &gt; 0 bytes returned before considering the error err. Doing so correctly handles IO errors that happen after reading some bytes and also both of the allowed EOF behaviors. Implementations of Read are discouraged from returning a zero byte count with a nil error, except when len(p) == 0. Callers should treat a return of 0 and nil as indicating that nothing happened; in particular it does not indicate EOF. Implementations must not retain p." />
      <item value="BigEndian is the big-endian implementation of ByteOrder and AppendByteOrder." />
      <item value="LittleEndian is the little-endian implementation of ByteOrder and AppendByteOrder." />
      <item value="leverage" />
      <item value="The same as above, but now as a histogram, and only for the normal distribution. The histogram features both conventional buckets as well as sparse buckets, the latter needed for the experimental native histograms (ingested by a Prometheus server v2.40 with the corresponding feature flag enabled). The conventional buckets are targeted to the parameters of the normal distribution, with 20 buckets centered on the mean, each half-sigma wide. The sparse buckets are always centered on zero, with a growth factor of one bucket to the next of (at most) 1.1. (The precise factor is 2^2^-3 = 1.0905077...)" />
      <item value="The duration of the rate oscillation period" />
      <item value="the uniform distribution" />
      <item value="registry" />
      <item value="Create a summary to track fictional interservice RPC latencies for three distinct services with different latency distributions. These services are differentiated via a &quot;service&quot; label." />
      <item value="The current value of the average. After adding with Add(), this is updated to reflect the average of all values seen thus far." />
      <item value="A SimpleEWMA represents the exponentially weighted moving average of a series of numbers. It WILL have different behavior than the VariableEWMA for multiple reasons. It has no warm-up period and it uses a constant decay. These properties let it use less memory. It will also behave differently when it's equal to zero, which is assumed to mean uninitialized, so if a value is likely to actually become zero over time, then any non-zero value will cause a sharp jump instead of a small change. However, note that this takes a long time, and the value may just decays to a stable value that's close to zero, but which won't be mistaken for uninitialized. See http:play.golang.orgplitxBDr_RC for example." />
      <item value="VariableEWMA represents the exponentially weighted moving average of a series of numbers. Unlike SimpleEWMA, it supports a custom age, and thus uses more memory." />
      <item value="NewMovingAverage constructs a MovingAverage that computes an average with the desired characteristics in the moving window or exponential decay. If no age is given, it constructs a default exponentially weighted implementation that consumes minimal memory. The age is related to the decay factor alpha by the formula given for the DECAY constant. It signifies the average age of the samples as time goes to infinity." />
      <item value="DialContext specifies the dial function for creating unencrypted TCP connections. If DialContext is nil (and the deprecated Dial below is also nil), then the transport dials using package net. DialContext runs concurrently with calls to RoundTrip. A RoundTrip call that initiates a dial may end up using a connection dialed previously when the earlier connection becomes idle before the later DialContext completes." />
      <item value="DialContext connects to the address on the named network using the provided context. The provided Context must be non-nil. If the context expires before the connection is complete, an error is returned. Once successfully connected, any expiration of the context will not affect the connection. When using TCP, and the host in the address parameter resolves to multiple network addresses, any dial timeout (from d.Timeout or ctx) is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect. For example, if a host has 4 IP addresses and the timeout is 1 minute, the connect to each single address will be given 15 seconds to complete before trying the next one. See func Dial for a description of the network and address parameters." />
      <item value="Dial uses context.Background internally; to specify the context, use DialContext." />
      <item value="For TCP, UDP and IP networks, if the host is empty or a literal unspecified IP address, as in &quot;:80&quot;, &quot;0.0.0.0:80&quot; or &quot;[::]:80&quot; for TCP and UDP, &quot;&quot;, &quot;0.0.0.0&quot; or &quot;::&quot; for IP, the local system is assumed." />
      <item value="For IP networks, the network must be &quot;ip&quot;, &quot;ip4&quot; or &quot;ip6&quot; followed by a colon and a literal protocol number or a protocol name, and the address has the form &quot;host&quot;. The host must be a literal IP address or a literal IPv6 address with zone. It depends on each operating system how the operating system behaves with a non-well known protocol number such as &quot;0&quot; or &quot;255&quot;." />
      <item value="When using TCP, and the host resolves to multiple IP addresses, Dial will try each IP address in order until one succeeds." />
      <item value="The functions JoinHostPort and SplitHostPort manipulate a pair of host and port in this form." />
      <item value="The zone specifies the scope of the literal IPv6 address as defined in RFC 4007." />
      <item value="it must be enclosed in square brackets," />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="78" />
        <entry key="ENGLISH" value="79" />
      </map>
    </option>
  </component>
</application>